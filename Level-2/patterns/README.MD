# Паттерны для изучения: 
    1. Фасад
    2. Строитель
    3. Посетитель
    4. Комманда 
    5. Цепочка вызовов
    6. Фабричный метод 
    7. Стратегия
    8. Состояние 

# Подробноcти: 

# 1 Фасад

    Фасад — это структурный паттерн проектирования, который предоставляет простой интерфейс к сложной системе классов, библиотеке или фреймворку.

    Фасад — это простой интерфейс для работы со сложной подсистемой, содержащей множество классов. Фасад может иметь урезанный интерфейс, не имеющий 100% функциональности, которой можно достичь, используя сложную подсистему напрямую. Но он предоставляет именно те фичи, которые нужны клиенту, и скрывает все остальные.

    Фасад полезен, если вы используете какую-то сложную библиотеку со множеством подвижных частей, но вам нужна только часть её возможностей.

    К примеру, программа, заливающая видео котиков в социальные сети, может использовать профессиональную библиотеку сжатия видео. Но все, что нужно клиентскому коду этой программы — простой метод encode(filename, format). Создав класс с таким методом, вы реализуете свой первый фасад.
##  Аналогия из жизни:
    Когда вы звоните в магазин и делаете заказ по телефону, сотрудник службы поддержки является вашим фасадом ко всем службам и отделам магазина. Он предоставляет вам упрощённый интерфейс к системе создания заказа, платёжной системе и отделу доставки.
## 1.1 Применимость:
### Когда вам нужно представить простой или урезанный интерфейс к сложной подсистеме.

    Часто подсистемы усложняются по мере развития программы. 
    Применение большинства паттернов приводит к появлению меньших классов, но в бóльшем количестве.
    Такую подсистему проще повторно использовать, настраивая её каждый раз под конкретные нужды, но вместе с тем, применять подсистему без настройки становится труднее. 
    Фасад предлагает определённый вид системы по умолчанию, устраивающий большинство клиентов.

### Когда вы хотите разложить подсистему на отдельные слои.

    Используйте фасады для определения точек входа на каждый уровень подсистемы. 
    Если подсистемы зависят друг от друга, то зависимость можно упростить, разрешив подсистемам обмениваться информацией только через фасады.

    Например, возьмём ту же сложную систему видеоконвертации. 
    Вы хотите разбить её на слои работы с аудио и видео. 
    Для каждой из этих частей можно попытаться создать фасад и заставить классы аудио и видео обработки общаться друг с другом через эти фасады, а не напрямую.
## 1.2 Преимущества:
    Изолирует клиентов от компонентов сложной подсистемы.
## 1.3 Недостатки:
    Фасад рискует стать божественным объектом, привязанным ко всем классам программы.
# 2 Строитель

    Строитель — это порождающий паттерн проектирования, который позволяет создавать сложные объекты пошагово. 
    Строитель даёт возможность использовать один и тот же код строительства для получения разных представлений объектов.
## 2.1 Применимость:
### Когда вы хотите избавиться от «телескопического конструктора».
    Допустим, у вас есть один конструктор с десятью опциональными параметрами.
    Его неудобно вызывать, поэтому вы создали ещё десять конструкторов с меньшим количеством параметров. 
    Всё, что они делают — это переадресуют вызов к базовому конструктору, подавая какие-то значения по умолчанию в параметры, которые пропущены в них самих.
    Паттерн Строитель позволяет собирать объекты пошагово, вызывая только те шаги, которые вам нужны.
    А значит, больше не нужно пытаться «запихнуть» в конструктор все возможные опции продукта.

### Когда ваш код должен создавать разные представления какого-то объекта. 
    Например, деревянные и железобетонные дома.
    Строитель можно применить, если создание нескольких представлений объекта состоит из одинаковых этапов, которые отличаются в деталях.
    Интерфейс строителей определит все возможные этапы конструирования. Каждому представлению будет соответствовать собственный класс-строитель. 
    А порядок этапов строительства будет задавать класс-директор.

### Когда вам нужно собирать сложные составные объекты, например, деревья Компоновщика.
    Строитель конструирует объекты пошагово, а не за один проход.
    Более того, шаги строительства можно выполнять рекурсивно.
    А без этого не построить древовидную структуру, вроде Компоновщика.
    Заметьте, что Строитель не позволяет посторонним объектам иметь доступ к конструируемому объекту, пока тот не будет полностью готов.
    Это предохраняет клиентский код от получения незаконченных «битых» объектов.
## 2.2 Преимущества:
    Позволяет создавать продукты пошагово.
    Позволяет использовать один и тот же код для создания различных продуктов.
    Изолирует сложный код сборки продукта от его основной бизнес-логики.
## 2.3 Недостатки:
    Усложняет код программы из-за введения дополнительных классов.
    Клиент будет привязан к конкретным классам строителей, так как в интерфейсе директора может не быть метода получения результата.
# 3 Посетитель

    Посетитель — это поведенческий паттерн, который позволяет добавить новую операцию для целой иерархии классов, не изменяя код этих классов.
## Аналогия из жизни:
    Представьте начинающего страхового агента, жаждущего получить новых клиентов. Он беспорядочно посещает все дома в округе, предлагая свои услуги.
    Но для каждого из посещаемых типов домов у него имеется особое предложение.

    Придя в дом к обычной семье, он предлагает оформить медицинскую страховку.
    Придя в банк, он предлагает страховку от грабежа.
    Придя на фабрику, он предлагает страховку предприятия от пожара и наводнения.
## 3.1 Применимость:
    Когда вам нужно выполнить какую-то операцию над всеми элементами сложной структуры объектов, например, деревом.
    Посетитель позволяет применять одну и ту же операцию к объектам различных классов.

### Когда над объектами сложной структуры объектов надо выполнять некоторые не связанные между собой операции, но вы не хотите «засорять» классы такими операциями.
    Посетитель позволяет извлечь родственные операции из классов, составляющих структуру объектов, поместив их в один класс-посетитель. 
    Если структура объектов является общей для нескольких приложений, то паттерн позволит в каждое приложение включить только нужные операции. 

### Когда новое поведение имеет смысл только для некоторых классов из существующей иерархии.
    Посетитель позволяет определить поведение только для этих классов, оставив его пустым для всех остальных.
## 3.2 Преимущества:
    Упрощает добавление операций, работающих со сложными структурами объектов.
    Объединяет родственные операции в одном классе.
    Посетитель может накапливать состояние при обходе структуры элементов.
## 3.3 Недостатки:
    Паттерн не оправдан, если иерархия элементов часто меняется.
    Может привести к нарушению инкапсуляции элементов.

# 4 Команда
    Команда — это поведенческий паттерн проектирования, который превращает запросы в объекты, позволяя передавать их как аргументы при вызове методов, ставить запросы в очередь, логировать их, а также поддерживать отмену операций.

## Аналогия из жизни:
    Вы заходите в ресторан и садитесь у окна.
    К вам подходит вежливый официант и принимает заказ, записывая все пожелания в блокнот.
    Откланявшись, он уходит на кухню, где вырывает лист из блокнота и клеит на стену.
    Далее лист оказывается в руках повара, который читает содержание заказа и готовит заказанные блюда.

    В этом примере вы являетесь отправителем, официант с блокнотом — командой, а повар — получателем. 
    Как и в паттерне, вы не соприкасаетесь напрямую с поваром. 
    Вместо этого вы отправляете заказ с официантом, который самостоятельно «настраивает» повара на работу.
    С другой стороны, повар не знает, кто конкретно послал ему заказ.
    Но это ему безразлично, так как вся необходимая информация есть в листе заказа.

## 4.1 Применимость:
### Когда вы хотите параметризовать объекты выполняемым действием.
    Команда превращает операции в объекты. А объекты можно передавать, хранить и взаимозаменять внутри других объектов.
    Скажем, вы разрабатываете библиотеку графического меню и хотите, чтобы пользователи могли использовать меню в разных приложениях, не меняя каждый раз код ваших классов.
    Применив паттерн, пользователям не придётся изменять классы меню, вместо этого они будут конфигурировать объекты меню различными командами.

 ###   Когда вы хотите ставить операции в очередь, выполнять их по расписанию или передавать по сети.
    Как и любые другие объекты, команды можно сериализовать, то есть превратить в строку, чтобы потом сохранить в файл или базу данных.
    Затем в любой удобный момент её можно достать обратно, снова превратить в объект команды и выполнить.
    Таким же образом команды можно передавать по сети, логировать или выполнять на удалённом сервере.

### Когда вам нужна операция отмены.
    Главная вещь, которая вам нужна, чтобы иметь возможность отмены операций, — это хранение истории. Среди многих способов, которыми можно это сделать, паттерн Команда является, пожалуй, самым популярным.
    История команд выглядит как стек, в который попадают все выполненные объекты команд.
    Каждая команда перед выполнением операции сохраняет текущее состояние объекта, с которым она будет работать. 
    После выполнения операции копия команды попадает в стек истории, все ещё неся в себе сохранённое состояние объекта.
    Если потребуется отмена, программа возьмёт последнюю команду из истории и возобновит сохранённое в ней состояние.
    Этот способ имеет две особенности. Во-первых, точное состояние объектов не так-то просто сохранить, ведь часть его может быть приватным. Но с этим может помочь справиться паттерн Снимок.
    Во-вторых, копии состояния могут занимать довольно много оперативной памяти.
    Поэтому иногда можно прибегнуть к альтернативной реализации, когда вместо восстановления старого состояния команда выполняет обратное действие. 
    Недостаток этого способа в сложности (а иногда и невозможности) реализации обратного действия.

## 4.2 Преимущества:
    Убирает прямую зависимость между объектами, вызывающими операции, и объектами, которые их непосредственно выполняют.
    Позволяет реализовать простую отмену и повтор операций.
    Позволяет реализовать отложенный запуск операций.
    Позволяет собирать сложные команды из простых.
    Реализует принцип открытости/закрытости.

## 4.3 Недостатки:
    Усложняет код программы из-за введения множества дополнительных классов.

# 5 Цепочка обязанностей

    Цепочка обязанностей — это поведенческий паттерн проектирования, который позволяет передавать запросы последовательно по цепочке обработчиков.
    Каждый последующий обработчик решает, может ли он обработать запрос сам и стоит ли передавать запрос дальше по цепи.

## Аналог из жизни
    Вы купили новую видеокарту. Она автоматически определилась и заработала под Windows, но в вашей любимой Ubuntu «завести» её не удалось.
    Со слабой надеждой вы звоните в службу поддержки.

    Первым вы слышите голос автоответчика, предлагающий выбор из десятка стандартных решений.
    Ни один из вариантов не подходит, и робот соединяет вас с живым оператором.

    Увы, но рядовой оператор поддержки умеет общаться только заученными фразами и давать шаблонные ответы.
    После очередного предложения «выключить и включить компьютер» вы просите связать вас с настоящими инженерами.

    Оператор перебрасывает звонок дежурному инженеру, изнывающему от скуки в своей каморке.
    Уж он-то знает, как вам помочь!
    Инженер рассказывает вам, где скачать подходящие драйвера и как настроить их под Ubuntu. 
    Запрос удовлетворён. 
    Вы кладёте трубку.

## 5.1 Применимость:
### Когда программа должна обрабатывать разнообразные запросы несколькими способами, но заранее неизвестно, какие конкретно запросы будут приходить и какие обработчики для них понадобятся.
    С помощью Цепочки обязанностей вы можете связать потенциальных обработчиков в одну цепь и при получении запроса поочерёдно спрашивать каждого из них, не хочет ли он обработать запрос.

### Когда важно, чтобы обработчики выполнялись один за другим в строгом порядке.
    Цепочка обязанностей позволяет запускать обработчиков последовательно один за другим в том порядке, в котором они находятся в цепочке.

### Когда набор объектов, способных обработать запрос, должен задаваться динамически.
    В любой момент вы можете вмешаться в существующую цепочку и переназначить связи так, чтобы убрать или добавить новое звено.

## 5.2 Преимущества:
    Уменьшает зависимость между клиентом и обработчиками.
    Реализует принцип единственной обязанности.
    Реализует принцип открытости/закрытости.

## 5.3 Недостатки: 
    Запрос может остаться никем не обработанным.

# 6 Фабричный метод

    Фабричный метод — это порождающий паттерн проектирования, который определяет общий интерфейс для создания объектов в суперклассе, позволяя подклассам изменять тип создаваемых объектов.

## 6.1 Применимость:
### Когда заранее неизвестны типы и зависимости объектов, с которыми должен работать ваш код.
    Фабричный метод отделяет код производства продуктов от остального кода, который эти продукты использует.
    Благодаря этому, код производства можно расширять, не трогая основной.
    Так, чтобы добавить поддержку нового продукта, вам нужно создать новый подкласс и определить в нём фабричный метод, возвращая оттуда экземпляр нового продукта.

### Когда вы хотите дать возможность пользователям расширять части вашего фреймворка или библиотеки.
    Пользователи могут расширять классы вашего фреймворка через наследование. Но как сделать так, чтобы фреймворк создавал объекты из этих новых классов, а не из стандартных?

    Решением будет дать пользователям возможность расширять не только желаемые компоненты, но и классы, которые создают эти компоненты. А для этого создающие классы должны иметь конкретные создающие методы, которые можно определить.

    Например, вы используете готовый UI-фреймворк для своего приложения. Но вот беда — требуется иметь круглые кнопки, вместо стандартных прямоугольных. Вы создаёте класс RoundButton. Но как сказать главному классу фреймворка UIFramework, чтобы он теперь создавал круглые кнопки, вместо стандартных?

    Для этого вы создаёте подкласс UIWithRoundButtons из базового класса фреймворка, переопределяете в нём метод создания кнопки (а-ля createButton) и вписываете туда создание своего класса кнопок. Затем используете UIWithRoundButtons вместо стандартного UIFramework.
### Когда вы хотите экономить системные ресурсы, повторно используя уже созданные объекты, вместо порождения новых.
    Такая проблема обычно возникает при работе с тяжёлыми ресурсоёмкими объектами, такими, как подключение к базе данных, файловой системе и т. д.
    Представьте, сколько действий вам нужно совершить, чтобы повторно использовать существующие объекты:

    Сначала вам следует создать общее хранилище, чтобы хранить в нём все создаваемые объекты.
    При запросе нового объекта нужно будет заглянуть в хранилище и проверить, есть ли там неиспользуемый объект.
    А затем вернуть его клиентскому коду.
    Но если свободных объектов нет — создать новый, не забыв добавить его в хранилище.
    Весь этот код нужно куда-то поместить, чтобы не засорять клиентский код.

    Самым удобным местом был бы конструктор объекта, ведь все эти проверки нужны только при создании объектов. Но, увы, конструктор всегда создаёт новые объекты, он не может вернуть существующий экземпляр.

    Значит, нужен другой метод, который бы отдавал как существующие, так и новые объекты. Им и станет фабричный метод.

## 6.2 Преимущества:
    Избавляет класс от привязки к конкретным классам продуктов.
    Выделяет код производства продуктов в одно место, упрощая поддержку кода.
    Упрощает добавление новых продуктов в программу.
    Реализует принцип открытости/закрытости.
## 6.3 Недостатки:
    Может привести к созданию больших параллельных иерархий классов, так как для каждого класса продукта надо создать свой подкласс создателя.