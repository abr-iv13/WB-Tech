# Паттерны для изучения: 
    1. Фасад
    2. Строитель
    3. Посетитель
    4. Комманда 
    5. Цепочка вызовов
    6. Фабричный метод 
    7. Стратегия
    8. Состояние 

# Подробноcти: 

# 1 Фасад

    Фасад — это структурный паттерн проектирования, который предоставляет простой интерфейс к сложной системе классов, библиотеке или фреймворку.

    Фасад — это простой интерфейс для работы со сложной подсистемой, содержащей множество классов. Фасад может иметь урезанный интерфейс, не имеющий 100% функциональности, которой можно достичь, используя сложную подсистему напрямую. Но он предоставляет именно те фичи, которые нужны клиенту, и скрывает все остальные.

    Фасад полезен, если вы используете какую-то сложную библиотеку со множеством подвижных частей, но вам нужна только часть её возможностей.

    К примеру, программа, заливающая видео котиков в социальные сети, может использовать профессиональную библиотеку сжатия видео. Но все, что нужно клиентскому коду этой программы — простой метод encode(filename, format). Создав класс с таким методом, вы реализуете свой первый фасад.

##  Аналогия из жизни:
    Когда вы звоните в магазин и делаете заказ по телефону, сотрудник службы поддержки является вашим фасадом ко всем службам и отделам магазина. Он предоставляет вам упрощённый интерфейс к системе создания заказа, платёжной системе и отделу доставки.

## 1.1 Применимость:
    Когда вам нужно представить простой или урезанный интерфейс к сложной подсистеме.

    Часто подсистемы усложняются по мере развития программы. 
    Применение большинства паттернов приводит к появлению меньших классов, но в бóльшем количестве.
    Такую подсистему проще повторно использовать, настраивая её каждый раз под конкретные нужды, но вместе с тем, применять подсистему без настройки становится труднее. 
    Фасад предлагает определённый вид системы по умолчанию, устраивающий большинство клиентов.

    Когда вы хотите разложить подсистему на отдельные слои.

    Используйте фасады для определения точек входа на каждый уровень подсистемы. 
    Если подсистемы зависят друг от друга, то зависимость можно упростить, разрешив подсистемам обмениваться информацией только через фасады.

    Например, возьмём ту же сложную систему видеоконвертации. 
    Вы хотите разбить её на слои работы с аудио и видео. 
    Для каждой из этих частей можно попытаться создать фасад и заставить классы аудио и видео обработки общаться друг с другом через эти фасады, а не напрямую.

## 1.2 Преимущества:
    Изолирует клиентов от компонентов сложной подсистемы.

## 1.3 Недостатки:
    Фасад рискует стать божественным объектом, привязанным ко всем классам программы.

# 2 Строитель

    Строитель — это порождающий паттерн проектирования, который позволяет создавать сложные объекты пошагово. 
    Строитель даёт возможность использовать один и тот же код строительства для получения разных представлений объектов.

## 2.1 Применимость:
    Когда вы хотите избавиться от «телескопического конструктора».
    Допустим, у вас есть один конструктор с десятью опциональными параметрами.
    Его неудобно вызывать, поэтому вы создали ещё десять конструкторов с меньшим количеством параметров. 
    Всё, что они делают — это переадресуют вызов к базовому конструктору, подавая какие-то значения по умолчанию в параметры, которые пропущены в них самих.
    Паттерн Строитель позволяет собирать объекты пошагово, вызывая только те шаги, которые вам нужны.
    А значит, больше не нужно пытаться «запихнуть» в конструктор все возможные опции продукта.

    Когда ваш код должен создавать разные представления какого-то объекта. 
    Например, деревянные и железобетонные дома.
    Строитель можно применить, если создание нескольких представлений объекта состоит из одинаковых этапов, которые отличаются в деталях.
    Интерфейс строителей определит все возможные этапы конструирования. Каждому представлению будет соответствовать собственный класс-строитель. 
    А порядок этапов строительства будет задавать класс-директор.

    Когда вам нужно собирать сложные составные объекты, например, деревья Компоновщика.
    Строитель конструирует объекты пошагово, а не за один проход.
    Более того, шаги строительства можно выполнять рекурсивно.
    А без этого не построить древовидную структуру, вроде Компоновщика.
    Заметьте, что Строитель не позволяет посторонним объектам иметь доступ к конструируемому объекту, пока тот не будет полностью готов.
    Это предохраняет клиентский код от получения незаконченных «битых» объектов.

## 2.2 Преимущества:
    Позволяет создавать продукты пошагово.
    Позволяет использовать один и тот же код для создания различных продуктов.
    Изолирует сложный код сборки продукта от его основной бизнес-логики.

## 2.3 Недостатки:
    Усложняет код программы из-за введения дополнительных классов.
    Клиент будет привязан к конкретным классам строителей, так как в интерфейсе директора может не быть метода получения результата.

# 3 Посетитель

    Посетитель — это поведенческий паттерн, который позволяет добавить новую операцию для целой иерархии классов, не изменяя код этих классов.

## Аналогия из жизни:
    Представьте начинающего страхового агента, жаждущего получить новых клиентов. Он беспорядочно посещает все дома в округе, предлагая свои услуги.
    Но для каждого из посещаемых типов домов у него имеется особое предложение.

    Придя в дом к обычной семье, он предлагает оформить медицинскую страховку.
    Придя в банк, он предлагает страховку от грабежа.
    Придя на фабрику, он предлагает страховку предприятия от пожара и наводнения.

## 3.1 Применимость:
    Когда вам нужно выполнить какую-то операцию над всеми элементами сложной структуры объектов, например, деревом.
    Посетитель позволяет применять одну и ту же операцию к объектам различных классов.

    Когда над объектами сложной структуры объектов надо выполнять некоторые не связанные между собой операции, но вы не хотите «засорять» классы такими операциями.
    Посетитель позволяет извлечь родственные операции из классов, составляющих структуру объектов, поместив их в один класс-посетитель. 
    Если структура объектов является общей для нескольких приложений, то паттерн позволит в каждое приложение включить только нужные операции. 

    Когда новое поведение имеет смысл только для некоторых классов из существующей иерархии.
    Посетитель позволяет определить поведение только для этих классов, оставив его пустым для всех остальных.
## 3.2 Преимущества:
    Упрощает добавление операций, работающих со сложными структурами объектов.
    Объединяет родственные операции в одном классе.
    Посетитель может накапливать состояние при обходе структуры элементов.

## 3.3 Недостатки:
    Паттерн не оправдан, если иерархия элементов часто меняется.
    Может привести к нарушению инкапсуляции элементов.
