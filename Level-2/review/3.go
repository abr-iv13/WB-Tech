//3. Что выведет программа?
//Объяснить вывод программы.
//Объяснить внутреннее устройство интерфейсов и их отличие от пустых интерфейсов.
package main

import (
	"fmt"
	"os"
)

func Foo() error {
	var err *os.PathError = nil
	return err
}

// func Foo() (err *os.PathError) {
// 	err = nil
// 	return
// }

func main() {
	err := Foo()
	// fmt.Printf("%#v\n", err)
	fmt.Println(err) // nil

	//Функция Foo возвращает nil типа *os.PathError, результат мы сравниваем с nil типа nil,
	// откуда и следует их неравенство.
	fmt.Println(err == nil)

	//Нужно получить исходный тип и проверить его значение.
	// fmt.Println(err.(*os.PathError) == nil)
}

/*
Интерфейсный тип в Go — это своего рода определение.(абстракция которая описывает поведение других типов)
Он определяет и описывает конкретные методы, которые должны быть у какого-то другого типа.
Так-же интрефейсы не могут содержвать какие либо дынные, только методы(хранит поведение но не данные.).
В Go структура с методом будет удовлетворять интерфейсу просто самим фактом объявление метода.

interface {}

Пустой интерфейсный тип не описывает методы. У него нет правил. И поэтому любой объект удовлетворяет пустому интерфейсу.
interface{}  используется как объект любого типа.
*/
